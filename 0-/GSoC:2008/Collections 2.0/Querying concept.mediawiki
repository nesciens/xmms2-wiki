== Querying Concept ==

Querying of metadata will be done in two distinct ways, A and B. For convenience options C and D will also be supported

The collection-patterns are in [[client:sisy|sisy]]-notation.

=== Basic querying ===

For every id it is possible to query metadata field-value-source tuples. Any permutation of these three can be requested (eg. just value, just key, key+value etc.) Some constraints can be imposed on what metadata is retrieved (source-pref, field in ..., value in ..., source in ...). As for each id there can be no more then one row in the result these metadata need to be aggregated (the "aggregate" might return a complex datastructure, such as a list/dict though)

Then there is clustering and several mediaid-rows need to be merged into one cluster row. For this there are also aggregates.

==== A. Per medialist entry ====

The client developer provides a collection structure resulting in a medialist to the daemon. The daemon then queries the metadata from the sqlite-database, so that there is one row for every entry of the medialist and the rows are in the same order as the medialist.

Note that every cell of the query-result can contain an xmms2-datatype, so that for instance all metadata can be queried in a propdict:

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 fetch: {{ spec={ type=id,                arguments={}             }, label=id       },
         { spec={ type=value,             arguments={field=artist} }, label=artist   },
         { spec={ type=value,             arguments={field=album}  }, label=album    },
         { spec={ type=value,             arguments={field=title}  }, label=title    },
         { spec={ type=source_value_dict, arguments={field=size}   }, label=datasize }}
 
 result: {{ id=141,  artist=Evanescence,       album=Not For Your Ears, title=Taking Over Me (Long), datasize={plugin/id3v2=5304040, plugin/file=5326558} },
          { id=113,  artist=Evanescence,       album=Anywhere But Home, title=Thoughtless,           datasize={plugin/id3v2=8286281, plugin/file=8314880} },
          { id=1092, artist=Within Temptation, album=Mother Earth,      title=Mother Earth,          datasize={plugin/id3v2=8947303, plugin/file=8947840} },
          { id=141,  artist=Evanescence,       album=Not For Your Ears, title=Taking Over Me (Long), datasize={plugin/id3v2=5304040, plugin/file=5326558} }}

==== B. Per cluster - The not so fancy version ====

RFC

The client developer supplies the daemon with a list of the following format:
 main structure: several of <code>label aggregate more1</code>
 where more1 is depending on the aggregate, but typically is <code>more2 data type more3</code>
 where more2 is typically depending on the aggregate and more3 is depending on the type, but both are typically several of <code>key field</code>
The client developer also supplies a list of labels to fetch, a list of label,collation to cluster by (these labels should have aggregate <code>none</code>) and a list of label,collation to order by.

For example (insertion is only for humans and everything is simple sequential for the daemon):
 coll: reference[reference=Gothic Metal,namespace=Playlists]
 specs:
     artist none
         data value
             field artist
             source-preference default
     albums implode
         glue ", "
         distinct true NOCASE
         order true NOCASE ASC 
         data value
             field album
             source-preference default
     NULL
 fetch:
     artist albums NULL
 cluster by:
     artist NOCASE
     NULL
 order by:
     artist NOCASE
     NULL

 result: [{artist = "Evanescence",       albums="Anywhere But Home, Not For Your Ears"},
          {artist = "Within Temptation", albums="Mother Earth"}]

Another example:
 coll: reference[reference=Gothic Metal,namespace=Playlists]
 specs:
     artist none
         data value
             field artist
             source-preference default
     albums implode
         glue +
         distinct false
         order true NOCASE DESC
         data value
             field album
             source-preference default
     titles implode
         glue " and "
         data value
             field title
     NULL
 fetch:
     artist albums titles NULL
 cluster by:
     artist NOCASE
     NULL
 order by:
     artist NOCASE
     NULL

 result: [{artist = "Evanescence",       albums="Not For Your Ears+Not For Your Ears+Anywhere But Home", titles="Taking Over Me (Long) and Thoughtless and Taking Over Me (Long)"},
          {artist = "Within Temptation", albums="Mother Earth", titles="Mother Earth"}]

Yet another:
 coll: universe
 specs:
     field none
         data field
     min_id min
         data id
     max_id max
         data id
     NULL
 fetch:
     field ids NULL
 cluster by:
     field NOCASE
     NULL
 order by:
     NULL

 result:
{| border="1" |
|-
! field !! min_id !! max_id
|-
|added || 2 || 1166
|-
|album || 2 || 1166
|-
|artist || 4 || 1149
|-
|bitrate || 2 || 1166
|-
|bpm || 88 || 1071
|-
|chain || 2 || 1166
|-
|channels || 2 || 1166
|-
|comment || 2 || 1166
|-
|comment_MusicMatch_Tempo || 118 || 118
|-
|composer || 4 || 1134
|-
|copyright || 506 || 506
|-
|date || 4 || 1166
|-
|duration || 2 || 1166
|-
|genre || 2 || 1166
|-
|grouping || 403 || 403
|-
|isvbr || 5 || 1134
|-
|laststarted || 2 || 1166
|-
|lmod || 2 || 1166
|-
|mime || 2 || 1166
|-
|original_artist || 506 || 506
|-
|partofset || 17 || 870
|-
|performer || 4 || 1134
|-
|picture_front || 34 || 675
|-
|picture_front_mime || 34 || 675
|-
|publisher || 4 || 1134
|-
|sample_format || 2 || 1166
|-
|samplerate || 2 || 1166
|-
|size || 2 || 1166
|-
|status || 1 || 1166
|-
|test || 1156 || 1156
|-
|timesplayed || 2 || 1166
|-
|title || 2 || 1166
|-
|tracknr || 4 || 1165
|-
|url || 15 || 1166
|}

==== B'. Per cluster - The fancy version ====

The client developer provides a collection structure to the daemon and a list of things ids in a cluster should have in common, for instance genre, artist or album. The daemon then queries the metadata from the sqlite-database, so that there is one row per cluster. If no things to have in common are specified all ids in the collection will be in one cluster. If there are n items in the cluster-by argument, the data will be contained in n recursive dicts.

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 cluster-by: {{ spec={type=value, arguments={field=artist}}, collation=NOCASE }}
 fetch: {{ spec={ type=id_list,                arguments={}             }, label=ids      },
         { spec={ type=value_list,             arguments={field=album}  }, label=albums   },
         { spec={ type=value_list,             arguments={field=title}  }, label=titles   },
         { spec={ type=source_value_list_dict, arguments={field=size}   }, label=datasize }}
 
 result: { Evanescence = { ids={113, 141},
                           albums={Anywhere But Home, Not For Your Ears},
                           titles={Thoughtless, Taking Over Me (Long)},
                           datasize={plugin/id3v2={5304040, 8286281}, plugin/file={5326558, 8947840}} },
           Within Temptation = { ids={1092},
                                 albums={Mother Earth},
                                 titles={Mother Earth},
                                 datasize={plugin/id3v2={8947303}, plugin/file={8947840}} }}

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 cluster-by: {}
 fetch: {{ spec={ type=id_list,                arguments={}             }, label=ids      },
         { spec={ type=value_list,             arguments={field=artist} }, label=artists  },
         { spec={ type=value_list,             arguments={field=album}  }, label=albums   },
         { spec={ type=value_list,             arguments={field=title}  }, label=titles   },
         { spec={ type=source_value_list_dict, arguments={field=size}   }, label=datasize }}
 
 result: {{ ids={113, 141, 1092},
            artists={Evanescence, Evanescence, Within Temptation},
            albums={Anywhere But Home, Not For Your Ears, Mother Earth},
            titles={Thoughtless, Taking Over Me (Long), Mother Earth},
            datasize={plugin/id3v2={5304040, 8286281, 8947303}, plugin/file={5326558, 8947840, 8947840}} }}

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 cluster-by: {{ spec={type=value, arguments={field=artist} }, collation=NOCASE },
              { spec={type=value, arguments={field=album}  }, collation=NOCASE },
              { spec={type=id,    arguments={}             }, collation=NOCASE }}
 fetch: {{ spec={ type=value,      arguments={field=title} }, label=title    },
         { spec={ type=value_list, arguments={field=size}  }, label=datasize }}
 
 result: { Evanescence = {
               Anywhere But Home = {
                   113 = { title=Thoughtless, datasize={8286281, 8314880} }
               },
               Not For Your Ears = {
                   141 = { title=Taking Over Me (Long), datasize={5304040, 5326558} }
               }
           },
           Within Tempation = {
               Mother Earth = {
                   1092 = { title=Mother Earth, datasize={8947303, 8947840} }
               }
           }
         }

Or, in a different universe:

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 cluster-by: [{ spec={type=value, arguments={field=artist} }, collation=NOCASE, label=artist},
              { spec={type=value, arguments={field=album}  }, collation=NOCASE, label=album },
              { spec={type=id,    arguments={}             }, collation=NOCASE, label=id }]
 fetch: [{ spec={ type=value,      arguments={field=title} }, label=title    },
         { spec={ type=value_list, arguments={field=size}  }, label=datasize }]
 
 result: [
 { artist = Evanescence,
   cluster = [
       { album = Anywhere But Home,
         cluster = [
             { id = 113,
               cluster = { title=Thoughtless, datasize={8286281, 8314880} }
             } ]
       },
       { album = Not For Your Ears,
         cluster = [
             { id = 141,
               cluster = { title=Taking Over Me (Long), datasize={5304040, 5326558} }
             } ]
       } ]
 },
 { artist = Within Tempation,
   cluster = [
       { album = Mother Earth,
         cluster = [
             { id = 1092,
               cluster = { title=Mother Earth, datasize={8947303, 8947840} }
             } ]
       } ]
 } ]

=== Functions for convenience ===

==== C. Per id ====

The client developer provides a collection structure to the daemon. The daemon then queries the metadata from the sqlite-database, so that there is one row for every id of the resulting collection. The result is ordered ascending by id.

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 fetch: {{ spec={ type=id,                arguments={}             }, label=id       },
         { spec={ type=value,             arguments={field=artist} }, label=artist   },
         { spec={ type=value,             arguments={field=album}  }, label=album    },
         { spec={ type=value,             arguments={field=title}  }, label=title    },
         { spec={ type=source_value_dict, arguments={field=size}   }, label=datasize }}
 
 result: {{ id=113,  artist=Evanescence,       album=Anywhere But Home, title=Thoughtless,           datasize={plugin/id3v2=8286281, plugin/file=8314880} },
          { id=141,  artist=Evanescence,       album=Not For Your Ears, title=Taking Over Me (Long), datasize={plugin/id3v2=5304040, plugin/file=5326558} },
          { id=1092, artist=Within Temptation, album=Mother Earth,      title=Mother Earth,          datasize={plugin/id3v2=8947303, plugin/file=8947840} }}

==== D. The legacy way ====

The client developer provides a collection structure to the daemon and an optional list of things ids in a group should have in common, for instance genre, artist or album (the groupby-argument). The daemon then queries the metadata from the sqlite-database, so that there are zero or more rows per group, showing all permutations of the "free" (not used for grouping) properties. If no groupby-list is supplied all requested properties are used for grouping.

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 group-by: {artist}
 fetch: {id, artist, album, title, size}
 
 result: {{ id=113,  artist=Evanescence,       album=Anywhere But Home, title=Thoughtless,  size=8286281 },
          { id=1092, artist=Within Temptation, album=Mother Earth,      title=Mother Earth, size=8947303 }}

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 group-by: {}
 fetch: {id, artist, album, title, size}
 
 result: {{ id=113,  artist=Evanescence,       album=Anywhere But Home, title=Thoughtless,           size=8286281 },
          { id=113,  artist=Evanescence,       album=Anywhere But Home, title=Thoughtless,           size=8314880 },
          { id=141,  artist=Evanescence,       album=Not For Your Ears, title=Taking Over Me (Long), size=5304040 },
          { id=141,  artist=Evanescence,       album=Not For Your Ears, title=Taking Over Me (Long), size=5326558 },
          { id=1092, artist=Within Temptation, album=Mother Earth,      title=Mother Earth,          size=8947303 },
          { id=1092, artist=Within Temptation, album=Mother Earth,      title=Mother Earth,          size=8947840 }}