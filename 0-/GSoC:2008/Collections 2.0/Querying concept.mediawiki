== Querying Concept ==

Querying of metadata will be done in two distinct ways, A and B. For convenience options C and D will also be supported

The collection-patterns are in [[client:sisy|sisy]]-notation.

=== Basic querying ===

For every id it is possible to query metadata field-value-source tuples. Any permutation of these three can be requested (eg. just value, just key, key+value etc.) Some constraints can be imposed on what metadata is retrieved (source-pref, field in ..., value in ..., source in ...). As for each id there can be no more then one row in the result these metadata need to be aggregated (the "aggregate" might return a complex datastructure, such as a list/dict though)

Then there is clustering and several mediaid-rows need to be merged into one cluster row. For this there are also aggregates.

==== A. Per medialist entry ====

The client developer provides a collection structure resulting in a medialist to the daemon. The daemon then queries the metadata from the sqlite-database, so that there is one row for every entry of the medialist and the rows are in the same order as the medialist.

Note that every cell of the query-result can contain an xmms2-datatype, so that for instance all metadata can be queried in a propdict:

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 fetch: {{ spec={ type=id,                arguments={}             }, label=id       },
         { spec={ type=value,             arguments={field=artist} }, label=artist   },
         { spec={ type=value,             arguments={field=album}  }, label=album    },
         { spec={ type=value,             arguments={field=title}  }, label=title    },
         { spec={ type=source_value_dict, arguments={field=size}   }, label=datasize }}
 
 result: {{ id=141,  artist=Evanescence,       album=Not For Your Ears, title=Taking Over Me (Long), datasize={plugin/id3v2=5304040, plugin/file=5326558} },
          { id=113,  artist=Evanescence,       album=Anywhere But Home, title=Thoughtless,           datasize={plugin/id3v2=8286281, plugin/file=8314880} },
          { id=1092, artist=Within Temptation, album=Mother Earth,      title=Mother Earth,          datasize={plugin/id3v2=8947303, plugin/file=8947840} },
          { id=141,  artist=Evanescence,       album=Not For Your Ears, title=Taking Over Me (Long), datasize={plugin/id3v2=5304040, plugin/file=5326558} }}



==== B'. Per cluster - The fancy version ====

The client developer provides a collection structure to the daemon and a list of things ids in a cluster should have in common, for instance genre, artist or album. The daemon then queries the metadata from the sqlite-database, so that there is one row per cluster. If no things to have in common are specified all ids in the collection will be in one cluster. If there are n items in the cluster-by argument, the data will be contained in n recursive dicts.

===== Jan 19 2009 version II (KISS) =====

 Fuck clusters.

 coll = <collection>
 fetch = list (
     ...
     dict (
         [ "type" = "random" | "metadata" | "id" ] // default: metadata

         // some constraints
         [ "field" = <string> | list ( <strings> ) ]
         [ "value" = <string> | list ( <strings> ) ]
         [ "source" = list ( <strings,ints> ) ]
         [ "source-pref" = <string> ]
 
         // what to acquire
         "acquire" = list (
              [ "id" ]     // if type == metadata || id
              [ "field" ]  // if type == metadata
              [ "value" ]  // if type == metadata || random
              [ "source" ] // if type == metadata
         )
     )
     ...
 )
 order = list ( // an entry for each acquired datum
     ...
     dict (
         [ "collation" = "BINARY" | "NOCASE" | "INTCOLL" | "NATCOLL" ]
         [ "order" = "ASC" | "DESC" ]
     )
     ...
 )
 limits = list ( // an integer for each acquired datum
     ...
     <integer>
     ...
 )

====== Example ======
 coll = reference[reference=All,namespace=Playlists]
 fetch = list (
     dict (
         "field" = "artist"
         "acquire" = list ("value")
     )
     dict (
         "field" = "album"
         "acquire" = list ("value")
     )
     dict (
         "field" = list ("tracknr" "title")
         "acquire" = list ("id" "field" "value")
     )
 )
 order = NULL
 limits = NULL

 result = dict (
     "Sonata Arctica" = dict (
         "End Of This Chapter" = dict (
             "1247" = dict (
                 "tracknr" = list (
                     "9"
                 )
                 "title" = list (
                     "Victoria's Secret"
                 )
             )
         )
         "Silence" = dict (
             "1284" = dict (
                 "tracknr" = list (
                     "13"
                 )
                 "title" = list (
                     "The Power Of One"
                 )
             )
         )
     )
     "The Used" = dict (
         "The Used" = dict (
              "991" = dict (
                  "tracknr" = list (
                      "3"
                  )
                  "title" = list (
                      "Bulimic"
                  )
              )
         )
     )
 )

====== Example II - 2 random artists + associated albums + ids ======
 coll = universe
 fetch = list (
     dict (
         "field" = "artist"
         "acquire" = list ("value")
     )
     dict (
         "field" = "album"
         "acquire" = list ("value" "id")
     )
 )
 order = list (
     dict ( "type" = "random")
 )
 limits = list (
     2
 )

result = dict (
    "Nirvana" = dict ( ""                          = list ("632" "633" "635")
                       "In Utero"                  = list ("629")
                       "MTV Unplugged in New York" = list ("630")
                       "Nevermind"                 = list ("631")
                       "Unplugged in New York"     = list ("634") )
    "Sonata Arctica" = dict ( "Broken" = list (...)
                              ...
                              "Winterheart's Guild" = list (...) )
)
===== Jan 19 2009 version =====

 coll = <collection>
 cluster-by = dict (
     ...
     <label> = dict (
 
         // some constraints
         [ "field" = <string> | list ( <strings> ) ]
         [ "value" = <string> | list ( <strings> ) ]
         [ "source" = list ( <strings,ints> ) ]
         [ "source-pref" = <string> ]
 
         // how to determine distinctness
         [ "collation" = "BINARY" | "NOCASE" | "INTCOLL" | "NATCOLL" ] // default: NATCOLL
 
         // what to distinct on
         [ "by" = <function-tree> ] // default: "value"
     )
     ...
 )
 fetch = dict (
     ...
     <label> = dict (
         [ "type" = "aggregate" | "metadata" | "id" ] // default: metadata
 
         // if type == metadata
         [ "field" = <string> | list ( <strings> ) ]
         [ "value" = <string> | list ( <strings> ) ]
         [ "source" = list ( <strings,ints> ) ]
         [ "source-pref" = <string> ]
 
         // if type == aggregate
         "label" = <label>
 
         // specify representation
         [ "repr" = <aggregate-function-tree> ] //default: "value" if type == metadata
     )
     ...
 )
 order = list (
     ...
     dict (
         [ "type" = "aggregate" | "metadata" | "id" | "random" ] // default: metadata
 
         // if type == metadata
         [ "field" = <string> | list ( <strings> ) ]
         [ "value" = <string> | list ( <strings> ) ]
         [ "source" = list ( <strings,ints> ) ]
         [ "source-pref" = <string> ]
 
         // specify representation
         [ "repr" = <aggregate-function-tree> ] //default: "value" if type == metadata
 
         // how to order
         [ "collation" = "BINARY" | "NOCASE" | "INTCOLL" | "NATCOLL" ] // default: NATCOLL
         [ "order" = "ASC" | "DESC" ] // default: ASC
     )
     ...
 )

====== Example ======
 coll = reference[reference=All,namespace=Playlists]
 cluster-by = dict (
     "artist" = dict (
         "field" = "artist"
     )
 )
 fetch = (
     "artist" = dict (
         "type" = "aggregate"
         "repr" = dict (
             "func" = "ucase"
             "args" = list (
                 "artist"
             )
         )
     )
     "metadata" = dict (
          "type" = "metadata"
          "field" = list (
              "album"
              "title"
          )
          "repr" = dict (
              "func" = "dict"
              "args" = list (
                  "field"
                  dict (
                      "func" = "dict"
                      "args" = list (
                          "value"
                          "id"
                      )
                  )
              )
          )
     )
 )
 order = list (
     dict (
         "type" = "aggregate"
         "repr" = "artist"
         "order" = "DESC"
     )
 )

 result = list (
     dict (
         "artist" = "SONATA ARCTICA"
         "metadata" = dict (
             "album" = dict (
                 "End Of This Chapter" = 1247
                 "Silence" = 1284
             )
             "title" = dict (
                 "The Power Of One" = 1284
                 "Victoria's Secret" = 1247
             )
         )
     )
     dict (
         "artist" = "THE USED"
         "metadata" = dict (
             "album" = dict (
                 "The Used" = 991
             )
             "title" = dict (
                 "Bulimic" = 991
             )
         )
     )
 )

===== Pre-Jan 19 2009 version =====

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 cluster-by: {{ spec={type=value, arguments={field=artist}}, collation=NOCASE }}
 fetch: {{ spec={ type=id_list,                arguments={}             }, label=ids      },
         { spec={ type=value_list,             arguments={field=album}  }, label=albums   },
         { spec={ type=value_list,             arguments={field=title}  }, label=titles   },
         { spec={ type=source_value_list_dict, arguments={field=size}   }, label=datasize }}
 
 result: { Evanescence = { ids={113, 141},
                           albums={Anywhere But Home, Not For Your Ears},
                           titles={Thoughtless, Taking Over Me (Long)},
                           datasize={plugin/id3v2={5304040, 8286281}, plugin/file={5326558, 8947840}} },
           Within Temptation = { ids={1092},
                                 albums={Mother Earth},
                                 titles={Mother Earth},
                                 datasize={plugin/id3v2={8947303}, plugin/file={8947840}} }}

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 cluster-by: {}
 fetch: {{ spec={ type=id_list,                arguments={}             }, label=ids      },
         { spec={ type=value_list,             arguments={field=artist} }, label=artists  },
         { spec={ type=value_list,             arguments={field=album}  }, label=albums   },
         { spec={ type=value_list,             arguments={field=title}  }, label=titles   },
         { spec={ type=source_value_list_dict, arguments={field=size}   }, label=datasize }}
 
 result: {{ ids={113, 141, 1092},
            artists={Evanescence, Evanescence, Within Temptation},
            albums={Anywhere But Home, Not For Your Ears, Mother Earth},
            titles={Thoughtless, Taking Over Me (Long), Mother Earth},
            datasize={plugin/id3v2={5304040, 8286281, 8947303}, plugin/file={5326558, 8947840, 8947840}} }}

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 cluster-by: {{ spec={type=value, arguments={field=artist} }, collation=NOCASE },
              { spec={type=value, arguments={field=album}  }, collation=NOCASE },
              { spec={type=id,    arguments={}             }, collation=NOCASE }}
 fetch: {{ spec={ type=value,      arguments={field=title} }, label=title    },
         { spec={ type=value_list, arguments={field=size}  }, label=datasize }}
 
 result: { Evanescence = {
               Anywhere But Home = {
                   113 = { title=Thoughtless, datasize={8286281, 8314880} }
               },
               Not For Your Ears = {
                   141 = { title=Taking Over Me (Long), datasize={5304040, 5326558} }
               }
           },
           Within Tempation = {
               Mother Earth = {
                   1092 = { title=Mother Earth, datasize={8947303, 8947840} }
               }
           }
         }

Or, in a different universe:

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 cluster-by: [{ spec={type=value, arguments={field=artist} }, collation=NOCASE, label=artist},
              { spec={type=value, arguments={field=album}  }, collation=NOCASE, label=album },
              { spec={type=id,    arguments={}             }, collation=NOCASE, label=id }]
 fetch: [{ spec={ type=value,      arguments={field=title} }, label=title    },
         { spec={ type=value_list, arguments={field=size}  }, label=datasize }]
 
 result: [
 { artist = Evanescence,
   cluster = [
       { album = Anywhere But Home,
         cluster = [
             { id = 113,
               cluster = { title=Thoughtless, datasize={8286281, 8314880} }
             } ]
       },
       { album = Not For Your Ears,
         cluster = [
             { id = 141,
               cluster = { title=Taking Over Me (Long), datasize={5304040, 5326558} }
             } ]
       } ]
 },
 { artist = Within Tempation,
   cluster = [
       { album = Mother Earth,
         cluster = [
             { id = 1092,
               cluster = { title=Mother Earth, datasize={8947303, 8947840} }
             } ]
       } ]
 } ]

=== Functions for convenience ===

==== C. Per id ====

The client developer provides a collection structure to the daemon. The daemon then queries the metadata from the sqlite-database, so that there is one row for every id of the resulting collection. The result is ordered ascending by id.

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 fetch: {{ spec={ type=id,                arguments={}             }, label=id       },
         { spec={ type=value,             arguments={field=artist} }, label=artist   },
         { spec={ type=value,             arguments={field=album}  }, label=album    },
         { spec={ type=value,             arguments={field=title}  }, label=title    },
         { spec={ type=source_value_dict, arguments={field=size}   }, label=datasize }}
 
 result: {{ id=113,  artist=Evanescence,       album=Anywhere But Home, title=Thoughtless,           datasize={plugin/id3v2=8286281, plugin/file=8314880} },
          { id=141,  artist=Evanescence,       album=Not For Your Ears, title=Taking Over Me (Long), datasize={plugin/id3v2=5304040, plugin/file=5326558} },
          { id=1092, artist=Within Temptation, album=Mother Earth,      title=Mother Earth,          datasize={plugin/id3v2=8947303, plugin/file=8947840} }}

==== D. The legacy way ====

The client developer provides a collection structure to the daemon and an optional list of things ids in a group should have in common, for instance genre, artist or album (the groupby-argument). The daemon then queries the metadata from the sqlite-database, so that there are zero or more rows per group, showing all permutations of the "free" (not used for grouping) properties. If no groupby-list is supplied all requested properties are used for grouping.

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 group-by: {artist}
 fetch: {id, artist, album, title, size}
 
 result: {{ id=113,  artist=Evanescence,       album=Anywhere But Home, title=Thoughtless,  size=8286281 },
          { id=1092, artist=Within Temptation, album=Mother Earth,      title=Mother Earth, size=8947303 }}

 coll: reference[reference=Gothic Metal,namespace=Playlists]
 group-by: {}
 fetch: {id, artist, album, title, size}
 
 result: {{ id=113,  artist=Evanescence,       album=Anywhere But Home, title=Thoughtless,           size=8286281 },
          { id=113,  artist=Evanescence,       album=Anywhere But Home, title=Thoughtless,           size=8314880 },
          { id=141,  artist=Evanescence,       album=Not For Your Ears, title=Taking Over Me (Long), size=5304040 },
          { id=141,  artist=Evanescence,       album=Not For Your Ears, title=Taking Over Me (Long), size=5326558 },
          { id=1092, artist=Within Temptation, album=Mother Earth,      title=Mother Earth,          size=8947303 },
          { id=1092, artist=Within Temptation, album=Mother Earth,      title=Mother Earth,          size=8947840 }}