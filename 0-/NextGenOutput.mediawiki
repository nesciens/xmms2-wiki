//
// XMMS2 NextGen Output Doc
// David Richards aka oneman
//

Goals:

	Highest Quality, Performance, Reliability and Flexibility along with code readability and simplicity
	*	As few Mutex's as possible (looking good now)
	*	Low to zero possibility of underun
	*	Lowest CPU Usage (doing well here, but more flexibility for jack users desired)
	*	Fewest Copies of Bytes (doing fine here already)
	*	Most sensible defaults, most users will not need to touch output settings
	*	Optional, be it by compile time or runtime, crosslapping durring seeking or track jumping 
																					(Manual track change, not natural track progression)
	*	Optional Fade Down on pause, Fade In on Resume DONE RIGHT, optional length
	* Optional skipping of calculating latency in playtime (Only important for jack users, where its known and
																													ultimately irrelivant, and a long code path that could cause xrun)

	* Merge to -devel ASAP

Next Level Potential Goals:

	* Backwards playback (Possibly better done as an xform Not known yet)
	*	Internal Mixer, X number of tracks going at once
	*	Multiple Outputs 


Testing:

If you want to test this code, find me, oneman, in the xmms2 irc channel.




The output buffer:

	Currently when a user seeks or jumps tracks in the middle of playback, the output buffer is dumped. This can cause two glitches
	depending on several factors most importantly the sound at the moment. 1) A glitch pop or crack sound 2) A Gap in output
	In the prebeta of nextgen output I have a "stacked buffer" model, meaning, the buffer is not dumped on a seek or jump, the samples
	post seek or jump are just 'stacked' on the end of the existing output buffer as it rolls along 

	
Seek/jump in Dr. No:     ("Dump Buffer")

Time:		----------s----------
Output: ---------- ----------       << Glitch / Gap in output due to buffer dump

Seek/jump in nextgen-output prebeta:	("Stacked Buffer")

Time:		----------s----------
Output: ---------------------				<< Output is gapless, but the seek or jump is delayed by the size of the output buffer
									 ^									 There maybe a glitch in the sound, but it is generally less noticable due to no gap
									 Seek Heard Here		 The delay depends on the size of the output buffer and the sample size and rate
																			 The common case is the size of 32768 bytes and Stereo S16 Samples @ 44100khz
																			 This comes out to 2 bytes per samples times 2 for stereo or 32768 / 4 = 8192 samples
																			 8192 / 44.1 (samples per millisecond) = 185ms delay in hearing the seek 
																			 So the delay is about 1/5th of a second

There is no pleasing some people, many, none of which have tested this, claim that its a long time, and will make things feel laggy, etc.
In reality it ends up making the sound output more smooth and does not feel laggy. However I aim to please, and get this code into -devel
as soon as possible, so I think it should be possible for several buffer options be availible be it compile time or runtime options.
So lets call the buffer strategy in Dr. No the "dump buffer strategy", and the one currently in nextgen-output the "stacked buffer strategy"
Here is some other strategies. 

Crosslap Seek / Jump	("Crosslap Stacked Buffer")

Time:		----------s----------
Output: -----------=---------
									 ^ Some Samples from old audio and new are lapped
 

Crossfade Seek Jump ("Crossfade Crosslap Stacked Double Buffer")

	This is the same as above, but samples are also crossfaded, meaning volume for old is going down and new is going up
	The length of the crossfade would be configurable. This involves also a second ringbuffer, but it doesn't nessasarily
	mean a third ("mixed samples") ringbuffer. There could be a third mixed ringbuffer, or the two buffers could be mixed
	at the time that the output is read. Only testing will determine which is more effiecient if it matters. The cpu cycles
	needed to mix would be consistant everytime. The fade would start as soon as possible, this means that the lowest possible
	latency when seeking / jumping without a gap would happen, unlike the solo stacked buffer, we don't have to wait for it to
	be played out, merely for the next samples to be ready, before we start outputing the mix

Time:		----------s----------
Output: -----------==--------
									 ^ Samples are crossfaded and crosslapped


Continous switch Seek/jump ("Switched Double Buffer")

This is a compromise between the dumped buffer and stacked buffer, the buffer is not dumped, the output continues to output the old
samples until the new ones are availible, as soon as they are the next read will be from the other buffer. Thus Output will be continous,
and latency minimal. 

Crosslapped switch Seek/Jump ("Crosslapped Switched Double Buffer")
The same as above but crosslapped.







functions in output.c in nextgen-prebeta at this time:


xmms_output_private_data_get (xmms_output_t *output)
xmms_output_stream_type_add (xmms_output_t *output, ...)
xmms_output_format_list_free_elem (gpointer data, gpointer user_data)
xmms_output_format_list_clear(xmms_output_t *output)
update_playtime (xmms_output_t *output, int advance)
xmms_output_set_error (xmms_output_t *output, xmms_error_t *error)
song_changed_arg_free (void *data)
song_changed (void *data)
seek_done (void *data)
xmms_output_filler_state_nolock (xmms_output_t *output, xmms_output_filler_state_t state)
xmms_output_filler_state (xmms_output_t *output, xmms_output_filler_state_t state)
xmms_output_filler_seek_state (xmms_output_t *output, guint32 samples)
xmms_output_filler (void *arg)
xmms_output_read (xmms_output_t *output, char *buffer, gint len)
xmms_output_read_wait (xmms_output_t *output, char *buffer, gint len)
xmms_output_config_property_register (xmms_output_t *output, const gchar *name, const gchar *default_value, xmms_object_handler_t cb, gpointer userdata)
xmms_output_config_lookup (xmms_output_t *output, const gchar *path)
xmms_output_current_id (xmms_output_t *output)
xmms_playback_client_xform_kill (xmms_output_t *output, xmms_error_t *error)
xmms_playback_client_seekms (xmms_output_t *output, gint32 ms, gint32 whence, xmms_error_t *error)
xmms_playback_client_seeksamples (xmms_output_t *output, gint32 samples, gint32 whence, xmms_error_t *error)
xmms_playback_client_start (xmms_output_t *output, xmms_error_t *err)
xmms_playback_client_stop (xmms_output_t *output, xmms_error_t *err)
xmms_playback_client_pause (xmms_output_t *output, xmms_error_t *err)
xmms_playback_client_status (xmms_output_t *output, xmms_error_t *error)
xmms_playback_client_current_id (xmms_output_t *output, xmms_error_t *error)
xmms_playback_client_volume_set (xmms_output_t *output, const gchar *channel,
xmms_playback_client_volume_get (xmms_output_t *output, xmms_error_t *error)
xmms_playback_client_playtime (xmms_output_t *output, xmms_error_t *error)
xmms_output_latency (xmms_output_t *output)
xmms_output_status_set (xmms_output_t *output, gint status)
xmms_output_destroy (xmms_object_t *object)
xmms_output_plugin_switch (xmms_output_t *output, xmms_output_plugin_t *new_plugin)
xmms_output_new (xmms_output_plugin_t *plugin, xmms_playlist_t *playlist)
xmms_output_flush (xmms_output_t *output)
xmms_output_format_set (xmms_output_t *output, xmms_stream_type_t *fmt)
set_plugin (xmms_output_t *output, xmms_output_plugin_t *plugin)
xmms_volume_map_lookup (xmms_volume_map_t *vl, const gchar *name)
xmms_volume_map_equal (xmms_volume_map_t *a, xmms_volume_map_t *b)
xmms_volume_map_init (xmms_volume_map_t *vl)
xmms_volume_map_free (xmms_volume_map_t *vl)
xmms_volume_map_copy (xmms_volume_map_t *src, xmms_volume_map_t *dst)
xmms_volume_map_to_dict (xmms_volume_map_t *vl)
xmms_output_monitor_volume_thread (gpointer data)