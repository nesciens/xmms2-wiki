= Overview =

Collections (currently scheduled for DrGonzo) mark an important change in the way XMMS2 interacts with its Media Library.

A collection is a subset of the Media Library, or in other words, a group of songs.  It can be static or dynamic, ordered or not, but in the end it's just that: a set of media entries.

For instance, a collection can be "all songs by Led Zeppelin before 1975" or "all songs added to the Media Library less than 10 days ago" (dynamic collections).  It can also be an arbitrary sequence of songs: "Smells Like Teen Spirit", "Hotel California" and "The Sounds of Silence" (static collection).  It can even be an automatic static list, e.g. "10 songs randomly fetched from the collection 'Any Music But Usher'".

With just a few examples, we see that the concept of collections provides a solid basis for different concepts, previously separated in the API and the server: queries, views, playlists (static or "smart"), etc.  The goal of collections is indeed to unify them into one unique but powerful structure.

For the client developer, collections will replace SQL queries and allow persistence of "views" of the Library, dynamic playlists, and other such features.  The user will benefit from the new features hence possible in the clients: Party Shuffle playlists, saved queries common to all clients, etc.

= Rationale =

The current API allows powerful queries in the medialib db, saved playlists, etc.  Why change something if it's not broken?

The problem is that it ''will'' be broken as soon as we try to introduce new features, such as dynamic playlists, saved queries, etc.  While they could be hacked as hooks in a client, this solution is neither elegant, nor robust.  Connect several such clients and they will start competing to change the playlist or won't be able to share saved views of the medialib.

We can therefore conclude that these features must be implemented in the server, so that all clients can make a common use of them. However, since they require the selection of a subset of the library (e.g. "playlist containing only Beatles songs"), the only way to perform this currently is by using the corresponding SQL query. First, this implies that each client has created its own functions to generate the SQL query corresponding to the user's choice.  Second, parsing back the query into a usable structure (e.g. so that the user can edit its choice) is a major hassle.

The solution to this problem is to unify the way queries are represented, in a higher level of abstraction.

[[Image:Collections-raising-abstraction.png|frame|center|Raise of abstraction of the API with collections]]

In the diagram above, we clearly see the raise of the position of the API in the query flow.  As a consequence, the client only deals with an abstract representation of queries and the transformation to the SQL form is done by the server. This introduces a looser coupling between what the client sees and implementation of the Media Library on the server. Therefore, all clients and the server share the same representation of queries, which can be exchanged, read and written freely. Moreover, it allows to transparently change the storage system used by the Media Library.

Having such a universal representation of queries makes it possible to add features based on sets of songs on the server, such as saved views or Party Shuffle playlists.  In addition to that, by using operators to make collections orderable, we can represent not only sets but also ''lists'' of songs ; this allows us to generalize the concept of collections to handle the playlists.

This generalization can be exploited to refactor the playlist API. Instead of the current model, where there is one "active playlist" and separate "saved playlists" in the medialib, a more natural approach would be to always play one of the saved playlists, which would itself be a collection.  The interface would thus gain in uniformity.

In conclusion, collections are a new step towards abstraction of the access and usage of the Media Library, unification of previously separate concepts on the server, improvement of shared structures among clients, and creation of new varieties of playlists.

= Terminology =

; Media Library
: The Media Library is the entity containing all the Media.

; Media
: A playable entity, usually a piece of music.  It is identified by a unique id and stores informations about the entry as properties: the URI of the file, plus some technical informations (bitrate, mime-type, duration, etc) and possibly song metadata (title, artist, genre, etc). In practice, files and streams are the most common types of media.

; Property
: A property is an information attached to a given entity.  In practice, both Media and Collections can have properties.

; DAG (Directed Acyclic Graph)
: In mathematics, a Directed Acyclic Graph is a set of nodes (or vertices) connected by directed edges, without any directed cycle.

; Collection
: A collection is a subset of the Media Library, i.e. a group of Media. It can be static or dynamic (e.g. if resulting for a query). It can be unordered (set) or ordered (list).
:
: Operators are used on collections to form new collections (e.g. filter by artist, intersection set operation, etc).  Consequently, a collection is a DAG whose nodes are operators ; each node of such a graph is in fact a collection itself.
:
: The largest possible collection is the Media Library itself, which contains all the Media.

; Namespace
: Collections are organized in namespaces.  In other words, the space where collections live is partitioned in several non-overlapping areas, and each collection belongs to one and only one of these namespaces.
:
: The two namespaces expected at this point are "Collections" and "Playlists".  More might be added later on.
:
: Note that, from a collection in a given namespace, it is possible to reference another collection in a different namespace.

[[Image:Collection-namespaces.png|frame|center|Namespaces in the collection space]]

; Mediaset
: A media set is (surprise) a set of media, i.e. an unordered collection.

; Medialist
: A media list is (surprise-bis) a list of media, i.e. an ordered collection.

; Operator
: Operators are nodes in the collection DAG. They are used to combine and restrict collections.  Therefore, the result (output) of an operator is always a collection.  The input varies: some operators take no input (e.g. idlist), some take one collection as input (e.g. match, complement), some take two collections as input (e.g. union, intersection).
:
: There are different types of operators
: 
: Exemples of operators include:
* set operators: union, intersection, complement
* filtering operators: match, contain, larger, smaller
* list operators: idlist, idqueue, Party Shuffle

: Each operator outputs a specific type of collection. The first two types of operators (set and filtering) produce mediasets; the last type (list) produces medialists.
: 
: '''Note:''' it was said above that collections have properties. It would be more accurate to say that ''operators'' have properties. Read ---below for a discussion on collections vs. operators.

; idlist
: An idlist is an operator that stores a list of media ids. It takes no input and outputs the medialist corresponding to its list of ids.

; Playlist
: The conventional definition of a playlist is a list of songs. Therefore, in our vocabulary, it is a medialist and hence an ordered collection.  For instance, a playlist can correspond to an idlist.
:
: Note that not ''all'' collections can be seen as playlists ; mediasets cannot, because there would be no way to determine the play order.

= The Concept of Collections =

Images speak better than words, so let's have a look at the representation of a collection:

[[Image:Collection-diagram-example-1.png|frame|center|Sample collection graph]]

This diagram represents the definition of the <span style="font-variant:small-caps">UberSound</span> collection (bottom).

Dashed blue round boxes are references to existing collections. Yellow boxes are operators and arrows connect their inputs and outputs.  The name of each operator appears in the top part of the box, while properties (if any) appear in the lower part.  The green squares represent the content (i.e. list of media ids) of the idlist operator [5].

The <span style="font-variant:small-caps">All Media</span> collection is a special collection containing all the media ; it is equivalent to considering the whole Media Library.  The <span style="font-variant:small-caps">Boring Playlist</span> collection has been defined previously ; its definition is not shown here.

The informal definition of <span style="font-variant:small-caps">UberSound</span> is: all media by Beck released between 1999 and 2004, including additional media specified in [5], except media found in the <span style="font-variant:small-caps">Boring Playlist</span> collection.

It is important to understand that collections appear at every step of the graph: at the input of operator LARGER [2] ("all media"), at the output of operator [2] and input of operator [3] ("all media after 1999"), at the output of operator [3] ("all media between 1999 and 2004"), at the output of operator [4] ("all media by Beck, between 1999 and 2004"), etc.  However, only the collection at the output of operator [8] has a label (<span style="font-variant:small-caps">UberSound</span>), others are just intermediate (anonymous) collections.


The usage of operators is quite self-explanatory in this example, but let's have an exhaustive overview of the different types of operators available.

== Collection Operators ==

We can split the collection operators in three types:
* Set operators
* Filter operators
* List operators

=== Set Operators ===

Set operators allow grouping and combination of multiple collections.

[[Image:Collection-operators-set.png|frame|center|Collection ''set'' operators]]

The output of set operators is a mediaset.

Description of the operators:

* '''<code>and</code>''': intersection operator. The resulting collection only contains media present in /both/ input collections.
* '''<code>or</code>''': union operator. The resulting collection contains all media present in /either/ input collections.
* '''<code>not</code>''': complement operator. The resulting collection contains all media /not/ present in the input collection.

=== Filter Operators ===

Filter operators impose restrictions on collections.

[[Image:Collection-operators-filter.png|frame|center|Collection ''filter'' operators]]

The output of filter operators is a mediaset.

Filter operators are configured using their two properties:

* The '''<code>field</code>''' property determines which property of the media should have its value extracted for comparison (<code>V<sub>m</sub></code>).
* The '''<code>value</code>''' property determines the value to compare with (<code>V<sub>o</sub></code>)

Description of the operators:

* '''<code>match</code>''': The resulting collection only contains media for which <code>V<sub>m</sub></code> exactly matches <code>V<sub>o</sub></code>.
* '''<code>contain</code>''': The resulting collection only contains media for which <code>V<sub>m</sub></code> contains <code>V<sub>o</sub></code>.
* '''<code>larger</code>''': The resulting collection only contains media for which <code>V<sub>m</sub></code> is larger than <code>V<sub>o</sub></code>.
* '''<code>smaller</code>''': The resulting collection only contains media for which <code>V<sub>m</sub></code> is smaller than <code>V<sub>o</sub></code>.

=== List Operators ===

List operators create static, ordered collections.  Unlike the other two (dynamic) types of operators, list operators actually /store/ their content, as a list of media ids.  This is represented on the figure as a green stack of squares.

[[Image:Collection-operators-list.png|frame|center|Collection ''list'' operator]]

The output of list operators is a medialist.

Description of the operators:

* '''<code>idlist</code>''': a static list of media ids.
* '''<code>idqueue</code>''': a static list of media ids ; when used as a playlist, played songs are popped out of it.  The <code>history</code> property specifies how many played songs are kept before they are removed.
* '''<code>party shuffle</code>''': a static list of media ids, populated by a random selection of songs from the input collection until the list size reaches the <code>upcoming</code> property. Played songs are popped similarly to the idqueue operator, using the <code>history</code> property. More property could be added to further customize this operator.

Notes:
* List operators are especially useful to include or exclude some given media from a collection (using the set operators), and to create playlists!
* Special functions should be made available to create, edit and reorder the list of ids in a list operator.