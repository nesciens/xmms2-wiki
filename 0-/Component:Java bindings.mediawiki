{{ComponentHeader}}

= Summary =
Java bindings for the client library.

==Prerequisites==

Since DrDolittle Xmms2 ships some bindings to the language Java. To get those bindings on your machine you need some prerequisites met and installed:

* '''Installed JDK''' ([http://java.sun.com Java development kit] a jre is not enough!) (>=1.4.2): no matter if blackdown or sun, both are tested, Java5 works too. Don't know gcj but afaik this works too. java, javac and jar have to be in path.
* '''Installed SWIG''' ([http://www.swig.org]) (>=1.3.25): swig has to be in path.
* '''JAVA_HOME''' must be set, otherwise scons skips installation of the javabindings for now.

==Usage==

After you have them installed you are either a developer and want to use them to develop something nifty or you are a user and have no idea which client to choose now.

If you are a '''user''' go to http://x4x.sourceforge.net and grab X4X, atm the only java-client. Follow the X4X [http://x4x.sourceforge.net/wiki/index.php/Installation installationintructions] and hope everything works. Else visit #x4x on [irc://irc.freenode.net].

If you are a '''developer''' you can check the sourcecode swig and we generated in src/clients/lib/java. You have some choices of using the javabindings now, but before everything build doxygen docu, you will need it. javadoc is possible too. After that you have two main choices:

# Use the C-API style code: Your mainclass to use is org.xmms2.xmms2bindings.Xmmsclient. For documentation on the various functions check the c pendants, everything works exactly the same. Besides that option you have to choose if you use org.xmms2.JMain as your mainloop (which is recommended) or build your own (which is annoying, so use JMain!). I only explain the JMain-way a bit here, for ideas on building an own loop check our loop. To use JMain you have to implement CallbacksListener or extend CallbacksAdapter (you can only use one, not two, not three, only one). Just instantiate a JMain with your CallbacksListener as argument and use org.xmms2.xmms2bindings.Xmmsclient to work with xmms2. But be warned: NEVER USE WAIT() THEN. When you use a Mainloop, no matter which, you enter the async mode, so use result_notifier() instead of wait() then.
# Use the nice and nifty new things I wrote today afternoon (They are DrDolittle+WIP). Your classes are org.xmms2.Xmms2, org.xmms2.Xmms2Listener/-Adapter, org.xmms2.Xmms2Event and org.xmms2.Title. It works without all the org.xmms2.xmms2bindings.* things since they are not nice to read. Since you built the doc as mentionend above just check the nice examples that are in org.xmms2.Xmms2. In short words do the following things:

===Async way===
 
 Xmms2 bleh = Xmms2.getInstance("YourClientsName");
 bleh.connect();
 bleh.addXmms2Listener(new Xmms2Adapter(){
  .....
 });
 bleh.play();
 bleh.playlistListAsync();
 bleh.spinDown();

connect()/addListener()/spinDown() are quite important so be careful using them. You get every kind of data (no matter you wanted it or the server broadcastet it) via the Listeners methods. When someone is on the way of using that new name please contact dangertools on #x4x or #xmms2 since this second API isn't tested quite much.


This new and easy API follows more or less the MVC-pattern (if you ask yourself now "What the hell is a pattern?", go and buy a book, e.g. [http://www.amazon.de/exec/obidos/ASIN/0201633612/qid=1143472275/sr=8-2/ref=sr_8_xs_ap_i2_xgl/028-2164729-0413335]. It hurts your purse but will improve your skillz).

The '''model''' in this case is the class implementing org.xmms2.Xmms2Listener, the '''controller''' is the class using org.xmms2.Xmms2 and the '''view''' is whatever UI-framework you choose ;)

===Sync way===

Since I think that there are still some needs of calling things sync but with blocking I implemented some more methods that work on a second connection but totally sync. That means that the methods return directly to the caller after they have finished. All functions which return some useful data are now available as functionNameAsync() and a functionNameSync() where the *Async() methods return to all connected listeners whereas the *Sync() methods return directly and only to the caller. To have that working in a simple way org.xmms2.Xmms2Backoffice now has two connections, named clientName1 and clientName2. The first one is used for the async things, the second one only for the sync methods. Here some quick example:

 Xmms2 bleh = Xmms2.getInstance("YourClientsName");
 bleh.connect();
 Map configs = bleh.configvalListSync();
 /* Do some funny things with the configs */
 Title t = bleh.mlibGetTitleSync(currentIDSync());
 System.out.println(t);
 bleh.spinDown();

But be careful when doing such things with mlibSelectSync() e.g. which could probably return a huge list and therefor take some time.