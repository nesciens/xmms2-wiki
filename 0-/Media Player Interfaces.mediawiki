This page is an attempt at bringing together information about various works in progress to produce a common media player control interface. Note that in the context of this page, ''interface'' refers to interface in the sense of an API, not an interface through which a user interacts with a program.

'''<span style="color: red; font-weight: bold"> Note about the mailing list mpris at videolan dot org:</span> It should be an as ''LOW'' traffic list as possible and used only to coordinate the work, and when developers disagree on a part of the spec. Otherwise, please use this wiki page.'''

= Background =
== Overview ==
In August 2005, Milosz Derezynski (deadchip) and Frederic Fondriest (ciberfred) were working on defining an interface for remotely controlling BMPx (as opposed to using the BMPx GUI) over DBUS:

 <ciberfred> hey deadchip , one things i'm currently thinking, we could do
 something with dbus to uniformize call functions, so each player could share
 same 'dbus-commands'
 <~deadchip> ah
 <~deadchip> yeah
 <~deadchip> that would be a very good idea
 <ciberfred> it could be better to let user choose the daemon they wants :)
 <ciberfred> like xmms2, bmpx, or lamip or well mpd or others
 <~deadchip> yeah
 <~deadchip> that is really good
 <ciberfred> so binaries commands audio could send informations from user
 to theses daemons without need to re-code somethings different but similare for
 another audio player

Thus [http://bmpx.beep-media-player.org/site/MPRIS_Interfacing_Specification MPRIS] (Media Player Remote Interface Specification) was born - a fairly generic interface with commands that could be applied to control a wide range of media players. However, even though the phrase 'Media Player' is present in MPRIS, the specification was developed with the assumption that it would be applied to audio players.

=== About MPRIS ===
* Defines commands for controlling a media player (play, pause, stop, etc).
* Defines signals that notify clients of certain events on the media player.
* Does NOT define audio or video data streaming protocols.
** That is, a client can't request audio or video stream data over MPRIS

=== Chalyx ===
Meanwhile, [[Sham Chukoury]] (eleusis) was working on an XMMS2 client named HaX (now known as [[Client:Chalyx|Chalyx]]). At some point, he decided it would be a great idea to be able to have a single client that could control multiple players, such as XMMS2, MPD and maybe even BMPx. So he made an [[Media Player Interfaces/Chalyx API Comparison|API comparison table]].

Most of the actions defined in the table were eventually defined in the [http://git.xmms.se/?p=chalyx-eleusis.git;a=blob;f=src/Chalyx/services/service.py Service] abstract class in Chalyx (and subsequently [http://git.xmms.se/?p=chalyx-eleusis.git;a=blob;f=src/Chalyx/services/xmms2.py XMMS2] and [http://git.xmms.se/?p=chalyx-eleusis.git;a=blob;f=src/Chalyx/services/mpd.py MPD] service modules were developed). As such, any client that uses the Chalyx library (such as [http://git.xmms.se/?p=kjell.git;a=summary Kjell] and [[Client:Insanity|Insanity]]) is able to control both XMMS2 and MPD. The design of Chalyx permits the development of additional 'service' modules to allow clients to control other music player backends.

=== VLC ===
Fast forward to November 2006 and RafaÃ«l CarrÃ© from the VLC project decided to implement a DBUS control interface for VLC. He discovered MPRIS and decided to adapt it to his needs. RafaÃ«l also decided to mail other media player projects to revive the spirit of MPRIS, and all hell broke loose across 10 different mailing lists. Then, Mirsal Ennaime tried to bring the project back from the grave, with RafaÃ«l CarrÃ© and BMPx developers.

== Current ==
;Discussion
:Discussion was proceeding on the [http://developers.videolan.org/lists.html vlc-devel] mailing list. (see specific thread linked [[#See_Also|below]]) Milosz has proposed to set up an mpris-devel mailing list hosted by BMPx.
:A dedicated mpris at videolan.org mailing list is set up, it should be an as ''LOW'' traffic list as possible and used only to coordinate the work and when developpers disagree on a part of the spec. Otherwise, please use this wiki page.

== DBUS ==
;Advantages
* Widespread
;Disadvantages
* Doesn't work well over TCP? (e.g. compare with MPD's & XMMS2's support for tcp sockets)

== Projects involved ==
=== [http://xmms2.xmms.se XMMS2] ===
For XMMS2, a proxy could be developed to translate between DBUS and XMMS2's own [[Design of XMMS2#Middleware | IPC mechanism]]. ([[User:Anders Gustafsson|Anders]] may have already done some work on this)

=== [http://bmpx.beep-media-player.org BMPx] ===
=== [http://www.videolan.org/vlc VLC] ===
=== [http://amarok.kde.org Amarok] ===
=== [http://audacious-media-player.org Audacious] ===

== [[Media Player Interfaces/API Comparison|API Comparison]] ==
* [[Media Player Interfaces/API Comparison#Playback_control|Playback]]
* [[Media Player Interfaces/API Comparison#Playlist_control|Playlist]]
* [[Media Player Interfaces/API Comparison#Current_information|Current information]]
* [[Media Player Interfaces/API Comparison#Configuration_control|Configuration]]
* [[Media Player Interfaces/API Comparison#Library_control|Library]]
* [[Media Player Interfaces/API Comparison#Session_control|Session]]
* [[Media Player Interfaces/API Comparison#Signals|Signals]]
* [[Media Player Interfaces/API Comparison##I.2FO_control|I/O]]
* [[Media Player Interfaces/API Comparison#Output_control|Output]]
* [[Media Player Interfaces/API Comparison#Binary_data_storage|Binary data storage]]
* [[Media Player Interfaces/API Comparison#Other|Other]]

= The spec =
'''''DRAFT'''''

;MPRIS
:Media Player Remote Interfacing Specification

== Definitions ==

=== "Media Player" ===

An application, either with GUI or GUI-less (or which allows for both modes of operation) which is capable of playing back audio/video streams. The means by which it does accomplish that (e.g. which audio backend to use, and which output method) is out of the scope of this document.

The "Media Player" '''must''':
* Be able to play back at least local storage file streams.
* Be able to play back at least one stream at a time.

=== "Client" ===

The Client is an unspecified application that will interact with the "Media Player" using D-Bus protocol.
For example:

* A softphone, that pauses, or step the volume down, when a call is being received.
* An applet that nicely integrates in your desktop environment, to control your "Media Player".
* An instant messaging client which informs your buddies of what you're listening to.
* A monitor that stores in a database what you are listening to, for statistics purpose.
* A video editing software that calls an external "Media Player" to preview your work.

=== "Tracklist" ===

A list of media files which resides within the "Media Player", and whose implementation is opaque to the remote interface.

The "Tracklist" '''must''':
* Hold an ordered list of locations of the media files as URIs (e.g. file:// or <nowiki>http://</nowiki>). The implementation of this can be opaque, which means, it does not neccesarily need to store URIs, but upon remote request, it must be able to return an URI for a given media file.
* Keep the list in an ordered fashion. The order can be changed at any time trough e.g. sorting algorithms, in which case the "Media Player" must send information about the reordering trough it's remote interface

The "Tracklist" '''can''', but does not '''need''' to:
* Hold "Metadata" about media files

=== "Metadata" ===

"Metadata" is data that the files carry within themselves as a means of self-identification (commonly known as "tags"), or data that has been retrieved about the files trough other means, e.g. an internet service that provides additional data about particular media files.
"Metadata" is an array of dict entries in the form (string, variant) eg: {sv}.

''' TODO: agree on a formal list of common entries / required entries '''

'''This is what BMP sends:'''
I've copied and pasted our attribute definition code directly so it's clear to see which data type a particular attribute is.

The first field is the 'name' and is totally informal; it never gets send over DBus; the 2nd field _is_ the key of the key <-> value pair of the metadata; follows a type identifier, and then a flag rather meaningless for anything external:

The only '''required''' field in BMP metadata is 'location'

      {
        "Location",
        "location",
        VALUE_TYPE_STRING,
        true
      },
      {
        "Title",
        "title",
        VALUE_TYPE_STRING,
        true
      },
      {
        "Track",
        "tracknumber",
        VALUE_TYPE_INT,
        true
      },
      {
        "Time",
        "time",
        VALUE_TYPE_INT,
        true
      },
      {
        "Genre",
        "genre",
        VALUE_TYPE_STRING,
        true
      },
      {
        "Comment",
        "comment",
        VALUE_TYPE_STRING,
        true
      },
      {
        "Rating",
        "rating",
        VALUE_TYPE_INT,
        true
      },
      {
        "Date",
        "date",
        VALUE_TYPE_INT,
        true
      },
      {
        "Time Modified",
        "mtime",
        VALUE_TYPE_INT,
        true
      },
      {
        "Bitrate",
        "bitrate",
        VALUE_TYPE_INT,
        true
      },
      {
        "Samplerate",
        "samplerate",
        VALUE_TYPE_INT,
        true
      },
      {      {
        "MusicIP PUID",
        "puid",
        VALUE_TYPE_STRING,
        true
      },
      {
        "New Item",
        "new_item",
        VALUE_TYPE_INT,
        true
      },
      {
        "Track Hash",
        "hash",
        VALUE_TYPE_STRING,
        true
      },
      {
        "MusicBrainz Track ID",
        "mb_track_id",
        VALUE_TYPE_STRING,
        true
      },
      {
        "Artist",
        "artist",
        VALUE_TYPE_STRING,
        false
      },
      {
        "MusicBrainz Artist Id",
        "mb_artist_id",
        VALUE_TYPE_STRING,
        false
      },
      {
        "MusicBrainz Artist Sortname",
        "mb_artist_sort_name",
        VALUE_TYPE_STRING,
        false
      },
      {
        "Album",
        "album",
        VALUE_TYPE_STRING,
        false
      },
      {
        "MusicBrainz Album Id",
        "mb_album_id",
        VALUE_TYPE_STRING,
        false
      },
      {
        "MusicBrainz Release Date",
        "mb_release_date",
        VALUE_TYPE_STRING,
        false
      },
      {
        "Amazon Asin",
        "asin",
        VALUE_TYPE_STRING,
        false
      },
      {
        "Is MusicBrainz Album Artist",
        "is_mb_album_artist",
        VALUE_TYPE_INT,
        false
      },
      {
        "MusicBrainz Album Artist",
        "mb_album_artist",
        VALUE_TYPE_STRING,
        false
      },
      {
        "MusicBrainz Album Artist Id",
        "mb_album_artist_id",
        VALUE_TYPE_STRING,
        false
      },
      {
        "MusicBrainz Album Artist Sortname",
        "mb_album_artist_sort_name",
        VALUE_TYPE_STRING,
        false
      },
      {
        "Active Track",
        "active",
        VALUE_TYPE_INT,
        true
      },

        "Play count",
        "count",
        VALUE_TYPE_INT,
        true
      },
      {
        "File Type",
        "type",
        VALUE_TYPE_STRING,
        true
      },
      {
        "Volume UDI",
        "volume_udi",
        VALUE_TYPE_STRING,
        true
      },
      {
        "Device UDI",
        "device_udi",
        VALUE_TYPE_STRING,
        true
      },
      {
        "Volume Relative Path",
        "volume_relative_path",
        VALUE_TYPE_STRING,
        true
      }


Notes:
* MPRIS implementations MUST provide at least the ''Basic'' interface.
* Seeking and the reporting of current stream position will be done in milliseconds - players which can't handle millisecond-level resolution should round up or down to the nearest position they can handle.

== D-Bus ==

=== DBus Stuff ===

Each player can request an own bus name as it likes, except that the prefix must be "org.mpris" and that the suffix must not contain the '.' character. For example:

* org.mpris.vlc
* org.mpris.bmp
* org.mpris.xmms2

The '''interface''' name of the player '''must''' always be "org.freedesktop.MediaPlayer" though.

(This deprecates the following comments:)

:: I think this is a bad idea, it's not the place for a interop Spec to force single instance behaviour without a good reason (i run amarok all the time and use vlc to play videos or streams...). Why not suggest that mediaplayers register with the well known service name ("org.freedesktop.MediaPlayer") with the options QueueService and suggest the media player should register an application specific service in addition?

:: if done that way we gain the feature to query the dbus daemon for all clients queued for that dbus name, so enumerating all current musicplayers that support the Spec is not problem. Contacting the players is not problem to because every client on dbus has a unique name anyway. DBus signal do AFAIK carry the dbus service name of the sending client, so there is no trouble knowing which player send a signal. [[User:textshell|textshell]]

=== The interface ===

All methods must be accessed through the interface org.freedesktop.MediaPlayer

i.e. calling Quit with qdbus on VLC would be:
 $ qdbus org.mpris.vlc /Player org.freedesktop.MediaPlayer.Quit

== The ''Basic'' interface, ( BMPx/VLC version ) ==

=== The Object Hierarchy ===

* / : Media Player identification

* /Player : Playback control

* /TrackList : TrackList management

== The Methods ==

=== / ===

==== Identity ====
Identify the "Media Player" as in "VLC 0.9.0", "bmpx 0.34.9", "Audacious 1.4.0" ...

   <method name="Identity">
     <arg type="s" direction="out"/>
   </method>

=== /TrackList ===

==== GetMetadata ====
Gives all meta data available for element at given position in the "TrackList"

  <method name="GetMetadata">
    <arg type="i" direction="in" />
    <arg type="a{sv}" direction="out" />
  </method>

==== GetCurrentTrack ====
Return the position of current URI in the "TrackList." The return value is zero-based, so the position of the first URI in the "TrackList" is 0. The behavior of this method is unspecified if there are zero elements in the "TrackList."

   <method name="GetCurrentTrack">
     <arg type="i" direction="out" />
   </method>

==== GetLength ====
Number of elements in the "TrackList"

   <method name="GetLength">
     <arg type="i" direction="out" />
   </method>

==== AddTrack ====
Appends an URI in the "TrackList", play it immediately if the 2nd argument is TRUE

   <method name="AddTrack">
     <arg type="s" />
     <arg type="b" />
   </method>

==== DelTrack ====
Removes an URI from the "TrackList", given its position

   <method name="DelTrack">
     <arg type="i" />
   </method>

==== Loop ====
Toggle playlist loop.

   <method name="Loop">
     <arg type="b" />
   </method>

==== Random ====
Toggle playlist shuffle / random. It may or may not play tracks only once.

   <method name="Random">
     <arg type="b" />
   </method>

=== /Player ===

==== Next ====
Goes to the next element (What if we're at the end? -- '''NOTE''' ''Nothing terrible needs to happen, the player should just ignore it. However UIs, and maybe not only UIs, can receive a hint as to whether there is a next track using the Caps API'')

   <method name="Next">
   </method>

==== Prev ====
Goes to the previous element (what if we're at the beginning? '''See above''')

   <method name="Prev">
   </method>

==== Pause ====
If playing : pause. If paused : unpause

   <method name="Pause">
   </method>

==== Stop ====
Stop playing.

   <method name="Stop">
   </method>

==== Play ====
If playing : rewind to the beginning of current track, else : start playing.

   <method name="Play">
   </method>

==== Repeat ====
Toggle the current track repeat.

   <method name="Repeat">
     <arg type="b" />
   </method>

==== Quit ====
Makes the "Media Player" exit.
'''Subject to change -- don't implement yet if you aren't VLC or BMP'''
 
   <method name="Quit">
   </method>

==== GetStatus ====
Return the status of "Media Player": 0 = Playing, 1 = Paused, 2 = Stopped. ([TODO] Expand the status stuff [Loop? Repeat?])

   <method name="GetStatus">
   <arg type="i" direction="out"/>
   </method>

==== GetMetadata ====
Gives all meta data available for the currently played element

  <method name="GetMetadata">
    <arg type="a{sv}" direction="out" />
  </method>

==== GetCaps ====
Return the "media player"'s current capabilities.

   <method name="GetCaps">
     <arg type="i" direction="out" />
   </signal>

RELATED:

   <signal name="CapsChange">
     <arg type="i" />
   </signal>


{|
|CAN_GO_NEXT||There is a current next track, or at least something that equals to it (that is, the remote can call the 'Next' method on the interface, and expect something to happen, heh)
|-
|CAN_GO_PREV||Same as for NEXT, just previous track/something
|-
|CAN_PAUSE||Can currently pause. This might not always be possible, and is yet another hint for frontends as to what to indicate
|-
|CAN_PLAY||Whether playback can currently be started. This might not be the case if e.g. the playlist is empty in a player, or similar conditions. Here, again, it is entirely up to the player to decide when it can play or not, and it should signalize this using the caps API.
|-
|CAN_SEEK||Whether seeking is possible with the currently played stream (UIs/frontends can then enable/disable seeking controls)
|-
|CAN_PROVIDE_METADATA||Whether metadata can be acquired for the currently played stream/source using GetMetadata at all.
|-
|PROVIDES_TIMING||[TODO] Should this really be caps, not flags?
|}

Note that the caps are a bitfield, currently defined as:


          NONE                  = 0,
          CAN_GO_NEXT           = 1 << 0,
          CAN_GO_PREV           = 1 << 1,
          CAN_PAUSE             = 1 << 2,
          CAN_PLAY              = 1 << 3,
          CAN_SEEK              = 1 << 4,
          CAN_PROVIDE_METADATA  = 1 << 5,
          PROVIDES_TIMING       = 1 << 6,

==== VolumeSet ====
Sets the volume (argument must be in [0;100])

   <method name="VolumeSet">
   <arg type="i"/>
   </method>

==== VolumeGet ====
Returns the current volume (must be in [0;100])
 
   <method name="VolumeGet">
   <arg type="i" direction="out"/>
   </method>

==== PositionSet ====
Sets the playing position (argument must be in [0;<track_length>] in milliseconds)

   <method name="PositionSet">
   <arg type="i"/>
   </method>

==== PositionGet ====
Returns the playing position (will be [0;<track_length>] in milliseconds)
 
   <method name="PositionGet">
   <arg type="i" direction="out"/>
   </method>

=== The signals ===

Signals must be emitted from /Player path and org.freedesktop.MediaPlayer interface.

==== TrackChange ==== 
Signal is emitted when the "Media Player" plays another "Track". Argument of the signal is the metadata attached to the new "Track"

   <signal name="TrackChange">
     <arg type="a{sv}"/>
   </signal>

==== StatusChange ==== 
Signal is emitted when the status of the "Media Player" change. The argument has the same meaning as the value returned by GetStatus.

   <signal name="StatusChange">
    <arg type="i"/>
   </signal>

==== CapsChange ==== 
Signal is emitted when the "Media Player" changes capabilities, Flags are CAN_GO_NEXT CAN_GO_PREV CAN_PAUSE CAN_PLAY CAN_SEEK CAN_PROVIDE_METADATA PROVIDES_TIMING. See [[#GetCaps|GetCaps method]]

   <signal name="CapsChange">
     <arg type="i" />
   </signal>

= See Also =
* [http://bmpx.beep-media-player.org/site/MPRIS_Interfacing_Specification MPRIS]
* [http://wiki.videolan.org/index.php/DBus-spec VLC DBUS Spec] based on MPRIS
* [http://thread.gmane.org/gmane.comp.video.videolan.vlc.devel/26649 Proposal for a common D-Bus interface for media players] thread
* [[Talk:Media Player Interfaces]]
* [http://wiki.videolan.org/index.php/MediaControlAPI MediaControlAPI]

[[Category:Developer ideas]]