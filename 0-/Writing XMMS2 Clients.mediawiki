{{Navbar}}

This page should eventually become a guide about things to consider when writing XMMS2 clients. Just a page for bringing ideas together, for now. You should drop by #xmms2 on Freenode if you need help writing a client.

= XMMS2 Client Guide =

This guide will help you understand how to build an XMMS2 client. It's not aimed at any language more like a reference of how different signals work.

== Choosing a Language ==
The XMMS2 client library comes with bindings to many languages. You should choose a language that suits you well. I recommend an interpreted language, since all computation is done in the server, and an interpreted language will let you develop faster.

== Connecting to XMMS2d ==
To be able to communicate with xmms2d you need to connect. The clientlib provides a data structure that symbolizes the connection called ''xmmsc_connection_t''. First, you have to initialize the connection with ''xmmsc_init()''. Like this:

 xmmsc_connection_t *connection;
 connection = xmmsc_init ("My client name");

The clientname is what will be presented to the xmms2d. This can not be NULL.

Now we connect:

 if (!xmmsc_connect (connection, NULL)) {
   fprintf (stderr, "Connection failed, error: %s", xmmsc_get_last_error (connection));
 }

Fine! Now we are connected. The second argument to ''xmmsc_connect'' is the path on where the client should connect. By default this is set to ''unix:///tmp/xmms-ipc-<username>'' as is the server's default also. All clients should respect the XMMS_PATH envrioment as default path, but can fall back on NULL if that connection failed. 

Since we are connected, we can now start sending commands to the server. But first we have to setup a way to get the responses. This guide will describe the asynchronous way of dealing with responses.

== Choosing a mainloop ==
XMMS2 clients should be written asynchronous, if they are using a GUI. Therefore, the choice of mainloop is kind of important. If you are using a widget toolkit, there is a big chance that that toolkit provides you with a mainloop. For example, GTK has GMainLoop, and QT has its own, too. You'll need to setup a callback from the mainloop to the xmmsipc. XMMS2 clientlib provides wrappers for some mainloops, but even if we don't provide a loop, it will be fairly easy to do it yourself. 

=== Integrate xmmsipc in your mainloop ===
After you have connected to the server with ''xmmsc_connect()'' the ''xmmsc_connection_t'' struct will be filled with a ipctransport. To extract the socket from this call ''xmmsc_ipc_fd_get()''. Then you feed this to your selectloop. When something is inbound on this socket you have to call ''xmmsc_ipc_io_in_callback()'' and when it disconnects you should call ''xmmsc_ipc_disconnect()''. Here we add select to our example:

 xmmsc_connection_t *connection;
 connection = xmmsc_init ("My client name");
 
 if (!xmmsc_connect (connection, NULL)) {
   fprintf (stderr, "Connection failed, error: %s", xmmsc_get_last_error (connection));
 }
 
 fd = xmmsc_ipc_fd_get (connection->ipc);
 FD_SET (fd, &fdset);
 while (TRUE) {
   ret = select (fd + 1, &fdset, NULL, NULL);
   if (ret > 0) {
     xmmsc_ipc_io_in_callback (connection->ipc);
   }
   usleep(10); // so we don't overload the proc when theres no incoming data
 }

The above code is a hack that has not been tested. Someone could probably provide a better example. This will dispatch all the notifiers we have.

== Sending commands to XMMS2 ==
There are three types of commands that could be sent to the server. There are '''methodcalls''', which just execute something in the server and return the result. There are '''broadcasts''' that are important and will notifiy you about the current state in the server and there are '''signals''' that will update you on status in the server, but are unimportant for the state. 

=== Methodcalls ===
There are two types of methodcalls, one type that will just execute something on the serverside and not give you any response except failure, and there are the ones that give you a result. Both types return a ''xmmsc_result_t''.

=== Broadcasts ===

=== Signals ===

 xmmsc_result_t *res;
 res = xmmsc_playback_play (connection);
 xmmsc_result_unref (res);

* Reference [[Design of XMMS2]] (section "XMMS2 Client Library" in particular. Or move that section to here?)
* Clients should respect ''XMMS_PATH'' environment variable, if set.
* Clients can store their config data in ''~/.xmms2/clients/''. Simple clients may get by with single conf files, like ''myclient.conf'', while more complex clients may use a subdirectory, such as ''advancedclient/''.
* Clients should not store daemon config keys and values in their own config - they should query the daemon instead. (some exceptions apply, for example, the IPC path to use)
* Clients using broadcast/signal callbacks (result notifiers) need to make sure I/O events are dispatched, for the callbacks to work properly. This is done by integrating ''xmmsc_ipc_io_in_callback'' with the clients' event loops. (TODO: more info about ''xmmsc_ipc_setup_with_gmain'' & Qt equivalent)

[[Category:XMMS2 Technical Details]]