== Client-side sketches ==

=== A libxmmsclient-sc sketch ===
This is a Service Client sketch illustrating some of the new ideas we had for a libxmmsclient-sc.

<pre>
/* Service client sketch using libxmmsclient-sc.
 * Queries the server for all available clients and prints their names.
 *
 * Illustrates some of the concepts discussed in the comments of my proposal
 * as well as a few other ideas of my own.
 */

#include <stdio.h>
#include <assert.h>
#include <string.h>

#include <xmmsclient/xmmsclient.h>

/* Header for Service Clients
 * Since libxmmsclient-sc and libxmmsclient would be so closely
 * related, it might make more sense to implement service client
 * functionality directly in the latter.
 */
#include <xmmsclient/xmmsclient-sc.h>

/* Metadata for this client */
static const char *name = "scsketch";
static int id;

static void
print_clients (xmmsc_connection_t *conn)
{
	int client_id;
	char *client_name;
	xmmsc_result_t *clients_res, *name_res;
	xmmsv_t *connected_clients, *client_list_entry;
	xmmsv_list_iter_t *it;
	xmmsv_t *client_name_v;

	/* This lists all clients that also registered for messages using
	 * xmmsc_sc_register.
	 * This information can be kept by the server, so this doesn't actually
	 * involve conversation between clients.
	 */
	clients_res = xmmsc_sc_list_clients (conn);
	xmmsc_result_wait (clients_res);

	/* The return value could be a list of ids. */
	connected_clients = xmmsc_result_get_value (clients_res);

	/* So we can loop through the list and query for client names. */
	xmmsv_get_list_iter (connected_clients, &it);
	while (xmmsv_list_iter_valid (it)) {
		xmmsv_list_iter_entry (it, &client_list_entry);
		xmmsv_get_int (client_list_entry, &client_id);

		/* This illustrates an introspection call for libxmmsclient-sc.
		 * The call to xmmsc_sc_get_name results in a message being sent
		 * to the queried client (identified by client_id) via
		 * xmmsc_broadcast_client_to_client_message.
		 * This broadcast reaches the callback set up by libxmmsclient-sc
		 * on the other client, which answers with its name.
		 * All other clients get the message as well, since this is a
		 * broadcast. However, their libxmmsclient-sc callback will simply
		 * fail to match their id with the destiny id in the message and
		 * ignore the broadcast.
		 */
		name_res = xmmsc_sc_get_name (connection, client_id);
		xmmsc_result_wait (name_res);

		/* Each message is identified by a random message id generated by
		 * the sender and passed along by the server to the receiver.
		 * The sender id and the random message id, thus, uniquely
		 * identify a message in the recipient side.
		 * The answer is expected to contain the same message id.
		 */

		client_name_v = xmmsc_result_get_value (name_res);
		xmmsv_get_string (client_name_v, &client_name);

		printf ("%s", client_name);

		/* The client itself is listed too.
		 * Since there may be other clients with the same name, an id
		 * match implies name match, but not the other way around.
		 */
		if (client_id == id) {
			assert (!strcmp (name, client_name));
			printf (" (hey, that's me!)");
		}

		printf ("\n");

		xmmsc_result_unref (name_res);
		xmmsv_list_iter_next (it);
	}

	xmmsc_result_unref (clients_res);
	return;
}

int
main (int argc, char **argv)
{
	xmmsc_connection_t *connection;
	xmmsc_result_t *res;
	xmmsv_t *my_id;

	/* Connect as usual.
	 * Error checking omitted for this example
	 */
	connection = xmmsc_init (name);
	xmmsc_connect (connection, getenv ("XMMS_PATH"));

	/* Register for communication with other clients.
	 * Under the hood, libxmmsclient-sc sets up its callback for
	 * xmmsc_broadcast_client_to_client_message, which is responsible both
	 * for answering to introspection calls (such as get_version) and for
	 * forwarding method calls to the corresponding functions provided by
	 * the client.
	 */
	res = xmmsc_sc_register (connection);
	xmmsc_result_wait (res);

	/* xmmsc_sc_register could either return NONE or the id assigned to
	 * this client by the server.
	 */
	my_id = xmmsc_result_get_value (res);

	/* As for the other metadata (such as version or category), they could
	 * be registered separately and kept by libxmmsclient-sc, using
	 * functions like xmmsc_sc_set_version. Using this approach,
	 * introspection calls could be answered directly by libxmmsclient-sc.
	 * An alternative would be for the client to register accessor methods,
	 * so that libxmmsclient-sc can dispatch introspection calls to them.
	 * Either way, it should probably be possible for a client to not
	 * register any metadata other than its name, since it doesn't make
	 * sense for a client that doesn't offer services (such as this one)
	 * to register them.
	 */
	xmmsv_get_int (my_id, &id);
	xmmsc_result_unref (res);

	/* Print the names of all connected clients. */
	print_names (connection);

	xmmsc_unref (connection);

	return EXIT_SUCCESS;
}
</pre>

=== First lower level sketch by nesciens ===
This first sketch illustrates some ideas for the contents of a client-to-client message, a callback for service clients to receive calls and method dispatching:

[http://e5239963acab7c70.paste.se/ some service client sketch or something]

=== nano-'s broken approach ===
This other sketch adheres more strictly to the idea of using broadcasts to communicate between clients. Doesn't allow synchronous communication.

[http://8d0939b7f618e224.paste.se/]

=== Second sketch by nesciens ===
A sketch of the changes needed in libxmmsclient and the basic idea behind libxmmsclient-sc.

[http://2af7060654a0a0b9.paste.se/ another sc sketch or something]

== Server-side sketches ==

=== Implement message-passing in ipc.c ===
It seems to be simpler and cleaner to implement message-passing between the clients through the server in ipc.c rather than creating a new object.

This could be accomplished by storing client ids in the corresponding xmms_ipc_client_t and adding a new command (XMMS_IPC_CMD_C2C_MSG) to the XMMS_IPC_OBJECT_SIGNAL, which, in process_msg, would be processed by calling a new method xmms_ipc_c2c_msg_write.

This xmms_ipc_c2c_msg_write method would locate and contact the destination client by searching for the client with the destination id (which should also be registered for a c2c broadcast in the regular way) in much the same way it happens in xmms_ipc_broadcast_cb.

=== A new object in the server ===
A new object could be introduced in the server, providing methods to forward messages and replies between clients. This object would be roughly a dumber version of the Service object and the IPC Pending Pool in puzzles' implementation.

This object (let's call it XMMS_IPC_OBJECT_COURIER for now) would be responsible for passing messages between the clients and matching replies with the corresponding queries, by keeping its own registry of pending messages.

It would be closely related to the main IPC object, in that it would use some of its data structures and functions to pass messages to clients. Specifically, it could use the list of IPC servers and clients in the IPC object to locate the destination of a message and then use xmms_ipc_client_msg_write to actually send it.

The xmms_ipc_client_St struct should be extended with a new field, "id", which represents the client's unique id. This id could easily be generated by the server when the client connects, and would be used to identify clients when sending messages.

===== Methods =====

This XMMS_IPC_OBJECT_COURIER would have two methods: xmms_courier_send_message and xmms_courier_reply, which are mostly compatible with nesciens' last sketch for the client-side.

''xmms_courier_send_message (xmms_ipc_client_t *client, int dest, int expect_reply, xmmsv_t *payload, uint32_cookie)''

Formats a c2c message in the form of a dict:

<pre>
"sender" : client->id
"dest" : dest
"payload" : payload
"expect_reply" : expect_reply
</pre>

If the message expects a reply (i.e., expect_reply == 1), generates a unique id for the message, stores it in the dict and records this message as pending in the pool of pending messages. It is sufficient to record the message, sender and destination ids, along with the cookie. Might make sense to record id = 0 in the c2c message does not accept replies.

Then looks up the destination client's xmms_ipc_client_t using its id in the list of clients kept by the IPC object, and uses xmms_ipc_client_msg_write to actually send the message to the destination client, using the cookie stored in its xmms_ipc_client_t (i.e., the one it uses for receiving the broadcast with messages).

----

''xmms_courier_reply (xmms_ipc_client_t *client, int msg_id, int expect_reply, xmmsv_t *payload, uint32 cookie)''

Looks for the destination using the provided msg_id in the pool of pending messages (and, once found, removes the entry corresponding to this id). Checks if the original message was really sent to the client which is trying to answer.

Proceeds similarly to send_message, with one fundamental difference: this time the ipc message sent should contain the cookie that was stored in the pool of pending messages instead of the one in the destination's xmms_ipc_client_t.

In order to delegate replies to clients that call service methods until the service actually responds, thus associating a xmmsc_result_t to the result of the method call, the courrier object would need to be special-cased in process_msg in ipc.c, maybe like XMMS_IPC_OBJECT_SIGNAL currently is.
The ipc message's cookie is passed along to both methods in process_msg so that it can be used to send back replies to clients.

==== Unresolved issues ====

1) What would be the objid and cmdid of the messages?

puzzles used objid = XMMS_IPC_OBJECT_SERVICE and cmdid = XMMS_IPC_CMD_BROADCAST for forwarding queries to services, objid = XMMS_IPC_OBJECT_SERVICE and cmdid = XMMS_IPC_CMD_REPLY when returning results.

One advantage of using broadcasts would be that the cookies associated with the client callbacks would be kept in their xmms_ipc_client_t as usual, so they could easily be retrieved by the courier object's methods.

== TODO ==
* ipc_servers_lock is not needed in courier.c
* Try to move code from courier.c to ipc.c and keep the structs opaque

[http://pastebin.com/snbKbw3e An idea] for how to expose in ipc.c only what the courier object will really need
* Unlocked/locked versions of store_pending?
* Move compare_uints to xmmsutil?
* <del>Make ids gint32</del>
* Documentation!
* <del>Replies should have XMMS_IPC_CMD_REPLY as cmdid</del>