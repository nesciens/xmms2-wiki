S4 is an attempt to create a new database backend for XMMS2. It lives in the s4 git repository, and you can find a version of XMMS2 with S4 and [[Collections 2.0]] in the xmms2-cippo repository (the s4coll2 branch).

==Design==
The XMMS2 media library does not map very well to a relational database. Every song can have a variable number of attributes, and they can be specific to just one song. That means the database can not be normalized the way you normally do with a relational database. The way it is handled with SQlite for XMMS2 is that a table called Media with the format {id, key, value, source} is created, and every attribute a song has is stored in there. This will obviously lead to a lot of duplication as every song by the artist Foobar will have {id, "artist", "Foobar", "plugin/id3v2"} set. S4 was designed to remove some of this redundancy and make a database optimized for XMMS2.

The basic structure in the S4 database is the entry. An entry maps to a song in XMMS2. An entry can have a variable number of attributes, but only a single key (that would be the song id in XMMS2).The structure looks something like this:
<pre>
key: "song_id", 1  -- The key is actually a key and a value
attributes:
  "title", "Two-Headed Boy", "plugin/id3v2"            -- Every attribute has a key, a value and a source
  "artist", "Neurtal Milk Hotel", "plugin/id3v2"       -- There can also be attributes with the same key
  "artist", "Neutral Milk Hotel", "client/xmms2-nycli" -- but different value and/or source.
</pre>
But how does this remove redundancy? There is still one artist attribute per song, but behind the scene S4 stores equal strings only once. There is still some redundancy in that the three pointers to the key, value and source are duplicated, but the data they point to are shared.

To speed up queries, S4 also provides indexes. By default there is only an index on the entry key, so in the above example searching for "song_id" and a value would be fast, while searching for "artist", or any other attribute would mean that all entries would have to be searched. The user may create indexes on any attribute, for example "artist", "title" or "album". XMMS2 creates indexes on "url" and "status" by default, because they are searched for a lot and need to be fast. Using an index is an O(log (n)) operation, where n is the number of entries in the index, while searching without an index is an O(n log (m)) operation, where n is the number of entries and m the maximum number of attributes an entry has (this is actually only true if there is one attribute with the key that is being searched for, if there are several attributes with the same key it will be slower).

==API==
The main API for S4 consists of just six calls
<pre>
s4_t* s4_open  (const char *filename, const char **indexes, int flags);
int   s4_close (s4_t *s4);
void  s4_sync  (s4_t *s4);
int   s4_add   (s4_t *s4,
                const char *key_a, const s4_val_t *val_a,
                const char *key_b, const s4_val_t *val_b,
                const char *source);
int   s4_del   (s4_t *s4,
                const char *key_a, const s4_val_t *val_a,
                const char *key_b, const s4_val_t *val_b,
                const char *source);

s4_resultset_t *s4_query (s4_t *s4, s4_fetchspec_t *fs, s4_condition_t *cond);
</pre>
There is also support functions to create conditions, fetch specification, source preferences and other structures needed for the querying. For more information on the different functions look at the doxygen documentation.

===Querying===
Perhaps the most interesting function is <code>s4_query</code>. It takes an S4 handle, a fetch specification and a condition and returns the data as the fetch specification requested for the entries matching the condition. The fetch specification is basically a list of (key, source-preference) pairs. It fetches the key using the attribute (or attributes) with the highest priority source according to the source-preference. If the key is NULL it will fetch everything.

==Internal Design==
Internally S4 consists of three parts: memory database, log writer and file reader/writer. On startup S4 reads in the data from the file and loads it into the memory database. The requested indexes are created (no indexes are saved on disk, only data) and it is ready to work. Whenever the user adds or deletes something from the database the copy in memory is modified to reflect this and a log entry is written to disk. The log can be used later to redo everything since the last time we wrote everything to disk. The log is implemented as a circular file, whenever we run out of space the database is written to disk before work can be resumed.

===Memory database===
This can be thought of as the working copy of the database. It also adds indexes to speed up searching. The basic structures are the entry defined as
<pre>
typedef struct {
        const char *key;     /* The key */
        const s4_val_t *val; /* and value of the entry (unique) */
        int size, alloc;     /* The used and allocated size of the attribute list */
        GStaticMutex lock;    

        entry_data_t *data;  /* The attribute list, resized with realloc whenever size > alloc */
} entry_t;

/* One of those per attribute in the attribute list */
typedef struct {
        const char *key;
        const s4_val_t *val;
        const char *src;
} entry_data_t;
</pre>

===Log===
The log is responsible for redoing any changes done after the last time the database was written to disk. Normally there will be nothing to redo when opening a database, but if the database was closed abruptly (for example if the program using the database crashed) there might be some changes not yet in the on-disk database. The log does not protect fully against power loss, because it just uses fflush (forcing the data to the kernel) but not sync (forcing the data on disk). This is because sync takes much longer than fflush. The FS will normally write data to the disk every 30. second (this depends on your system settings) and you will not loose more data than what was changed in those 30 seconds.

As have already been mentioned the log file is a circular file. The log size is defined in log.c as LOG_SIZE and is currently set to 2 MB. The log file will write log-entries until it hits then end, then it will write a special wrap-around log-entry and start writing at the beginning again. The log will never overwrite log-entries that contains data that has not been written to the on-disk database yet. A log-entry is defined as
<pre>
struct log_header {
        log_type_t type;  /* The type, can be add, delete or wrap-around */
        log_number_t num; /* The log number, this contains the offset into the log file
                           * and the round number (how many times the log file has been wrapped around)*/
        int32_t ka_len;   /* The length of the key_a string */
        int32_t va_len;   /* The length of the value_a string, or -1 if it is an integer */
        int32_t kb_len;   /* The length of the key_b string */
        int32_t vb_len;   /* The length of the value_b string, or -1 if it is an integer */
        int32_t s_len;    /* The length of the source string */
};
</pre>
If it is an add or delete log-entry it is followed by the key_a, value_a, key_b, value_b and source.

===On-disk database===
The on-disk database has a very simple format. This is to make code reading and writing it simple and thus less likely of having bugs. The database-file starts with this header
<pre>
Offset Bytes  Description
0       4     Magic number
4       4     Version number
8      16     UUID
24      4     Last logpoint   
</pre>
The file starts with a magic string ("s4db") so we can check if it actually is an S4 database, followed by a version number to find out what format it is using. Then comes an UUID (this is randomly created when the database is created, and can be used to identify a database without using the filename). Last is the number of the last log-entry written when this file was written to disk. This can be used to determine if the log contains new data added after this file was written.

After the header a list of strings follow. They have the following format:
<pre>
(Offsets relative to the end of the last string
 or the header if this is the first string)

Offset Bytes  Description
0       4     String ID
4       4     String length
8       x     The actual string
</pre>
To indicate that there are no more strings 0xffffffff (-1) is written instead of an id.

After the strings the actual data comes. The data consists of quintuples of int32_ts defined like this
<pre>
(Offsets relative to the previous data entry,
 or the end of the strings if this is the first data)

Offset Bytes  Description
 0     4      String ID of entry key
 4     4      String ID or integer value of entry value
 8     4      String ID of attribute key
16     4      String ID or integer value of attribute value
20     4      String ID of attribute source
</pre>
If the entry value is an integer, the entry key string ID is negated. If the attribute value is an integer value, the attribute key string ID is negated.

Here is a short example. Take the database
<pre>
key = "song_id"
value = 1
attributes:
  "title"  = "Song A"   (source "plugin/id3v2")
  "artist" = "Artist A" (source "plugin/id3v2")

key = "song_id"
value = 2
attributes:
  "title"  = "Song B"   (source "plugin/id3v2")
  "artist" = "Artist A" (source "plugin/id3v2")
</pre>
which could result in the following file
<pre>
(Header)
magic:           "midb"
version:         1
uuid:            a083753e-cfb5-49a7-b0de-2ca8fe2ee016
last_checkpoint: 200

(Strings)
1, 7, "song_id"
2, 5, "title"
3, 6, "artist"
4, 6, "Song A"
5, 8, "Artist A"
6, 6, "Song B"
7, 12, "plugin/id3v2"

-1

(Pairs)
(-1, 1, 2, 4, 7)
(-1, 1, 3, 5, 7)
(-1, 2, 2, 6, 7)
(-1, 2, 3, 5, 7)
</pre>

==CLI Tool==
There is a simple command-line tool for S4, named "s4", that can be used to examine an S4 database without using XMMS2. It supports querying, adding and deleting properties. There are five kinds of statements in the tool: statements with no return value, statements that return a condition, statements that return a fetch specification, statements that returns a result and statements that returns a list. If you write ".help;" in the tool you get the following list of statements
<pre>
All statements must end with a semicolon

Statements with no value:
.add <list>, <list>   - For every (key, val) from the first list it adds
                        the attributes (key, val, src) from the second list
.del <list>, <list>   - For every (key, val) from the first list it deletes
                        the attributes (key, val, src) from the second list
.exit                 - Exit the program
.help                 - Prints this help
.set key value        - Sets the option key to val
.set key              - Shows the value of the key
.set                  - Shows the value of all keys
.vars                 - Prints all bound variables

?var = <cond>         - Assigns cond to the condition variable var
%var = <fetch>        - Assigns fetch to the fetch variable var
@var = <result>       - Assigns var to something returning result
$var = <list>         - Assigns the list to the list variable var

Conditions (<cond>):
?var                  - Returns the condition bound to var
key = value           - Matches all entries where key equals value
key ~ value           - Matches all entries where key matches value
key < value           - Matches all entries where key is smaller than value
key > value           - Matches all entries where key is greater than value
= value               - Matches all entries where one or more keys equals value
~ value               - Matches all entries where one or more keys matches value
< value               - Matches all entries where one or more keys is smaller than value
> value               - Matches all entries where one or more keys is greater than value
+key                  - Matches all entries that has key
+                     - Matches everything
!cond                 - Matches everything cond does not match
cond1 & cond2         - Matches if both cond1 and cond2 matches
cond1 | cond2         - Matches if cond1 or cond2 matches

Fetch specification (<fetch>):
%var                  - Returns the fetch spec bound to var
[key1, .., keyn]      - Fetches keys 1 through n from matching entries
key                   - Fetches key from matching entries
_                     - Fetches everything from matching entries

Results (<result>):
.query <fetch> <cond> - Queries the database, returns a result

@var                  - Returns the result bound to var

Lists (<list>):
$var                  - Returns the list bound to the variable var
<result>[row, col]    - Returns the list at (row,col). If either row
                        or col is _, it will take all rows or cols
[key val src, ...]    - Creates a list
[key val, ...]        - Creates a list where source is set to default_source
</pre>
So an example session might be something like this (everything after the # are comments and not in the actual session)
<pre>
s4> ?cond = album="temple of the dog"; # Creates a condition and assigns it to the condition variable cond.
s4> %fetch = [title, tracknr];         # Creates a fetch specification and assigns it to the variable fetch.
s4> @res = .query %fetch ?cond;        # Queries the database with the condition and fetchspec above and saves the result in res
s4> $titles = @res[_, 0];              # Creates a list of all the titles (column 0)
s4> $tracknrs = @res[_, 1];            # Creates a list of all the tracknrs (column 1)
s4> $titles;                           # Prints the value in titles
list [title "Your Saviour" plugin/id3v2, title "Wooden Jesus" plugin/id3v2, title "Times of Trouble" plugin/id3v2,
title "Say Hello 2 Heaven" plugin/id3v2, title "Reach Down" plugin/id3v2, title "Pushin Forward Back" plugin/id3v2,
title "Hunger Strike" plugin/id3v2, title "Four Walled World" plugin/id3v2, title "Call Me a Dog" plugin/id3v2,
title "All Night Thing" plugin/id3v2]

s4> $tracknrs;                         # Prints the value in tracknrs
list [tracknr 8 plugin/id3v2, tracknr 7 plugin/id3v2, tracknr 6 plugin/id3v2, tracknr 1 plugin/id3v2, tracknr 2 plugin/id3v2,
tracknr 4 plugin/id3v2, tracknr 3 plugin/id3v2, tracknr 9 plugin/id3v2, tracknr 5 plugin/id3v2, tracknr 10 plugin/id3v2]

s4> $everything = @res[_, _];          # Puts everything in the list everything
s4> $everything;                       # Prints the value in everything
list [tracknr 8 plugin/id3v2, title "Your Saviour" plugin/id3v2, tracknr 7 plugin/id3v2, title "Wooden Jesus" plugin/id3v2,
tracknr 6 plugin/id3v2, title "Times of Trouble" plugin/id3v2, tracknr 1 plugin/id3v2, title "Say Hello 2 Heaven" plugin/id3v2,
tracknr 2 plugin/id3v2, title "Reach Down" plugin/id3v2, tracknr 4 plugin/id3v2, title "Pushin Forward Back" plugin/id3v2,
tracknr 3 plugin/id3v2, title "Hunger Strike" plugin/id3v2, tracknr 9 plugin/id3v2, title "Four Walled World" plugin/id3v2,
tracknr 5 plugin/id3v2, title "Call Me a Dog" plugin/id3v2, tracknr 10 plugin/id3v2, title "All Night Thing" plugin/id3v2]

s4> $first_title = @res[0, 0];         # Puts the value in row 0, column 0 in first_title
s4> $first_title;
list [title "All Night Thing" plugin/id3v2]

s4> @res[0, 0];                        # It doesn't have to go through a variable
list [title "All Night Thing" plugin/id3v2]

s4> $first_track = @res[0, 1];         # Puts the value in row 0, column 1 in first_track
s4> $first_track;
list [tracknr 10 plugin/id3v2]

s4> .exit;
</pre>